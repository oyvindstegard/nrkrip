#!/usr/bin/env perl
# Rip video streams from tv.nrk.no/tv.nrksuper.no
# Requires ffmpeg on PATH and Perl modules 'WWW::Curl', 'HTML::Parser'
# This script will only output UTF-8 encoded data, both for output and
# generated file names.

package nrkrip;

use strict;
use warnings;

use WWW::Curl::Easy;
use HTML::Parser;
use File::Basename qw(dirname basename);
use File::Path qw(make_path);
use Getopt::Long qw(:config bundling);
use Encode qw(encode);

# Encode strings printed to stdout/stderr as UTF-8
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

# Path to ffmpeg binary
use constant FFMPEG => 'ffmpeg';

# Version
use constant VERSION => '0.2';

# Fetch content at URL
# Takes URL as first argument.
sub http_fetch_body {
    my ($url) = @_;
    die("Need to supply URL!") unless $url;
    my $curl = WWW::Curl::Easy->new;
    $curl->setopt(CURLOPT_URL, $url);
    $curl->setopt(CURLOPT_FOLLOWLOCATION, 1);
    my $response_body;
    $curl->setopt(CURLOPT_WRITEDATA, \$response_body);
    my $retcode = $curl->perform();

    if ($retcode == 0) {
        my $response_code = $curl->getinfo(CURLINFO_HTTP_CODE);
        die("Unexpected http response code: $response_code") unless ($response_code eq 200);

        return $response_body;
    } else {
        die("An error happened: $retcode ".$curl->strerror($retcode)." ".$curl->errbuf."\n");
    }
}

# Takes URL as first argument.
# Returns a hash with metadata fields.
sub get_metadata {
    my ($url) = @_;
    if (not $url =~ /^https?:\/\/tv\.nrk(super)?\.no/) {
        return {};
    }

    my $html_content = &http_fetch_body($url);
    my %meta = ('url' => $url);
    my @context = ();
    my $text = '';

    # Season from URL (possibly)
    if ($url =~ /\/sesong-([0-9]+)/) {
        $meta{'season'} = $1;
    }

    # HTML parser handler routines
    my $start_handler = sub {
        my ($tagname, $attr) = @_;
        my $class = exists $attr->{'class'} ? $attr->{'class'} : '';
        push @context, [$tagname, $class];

        if ('meta' eq $tagname) {
            if (exists $attr->{'name'} && exists $attr->{'content'}) {
                my ($metaname, $content) = ($attr->{'name'}, $attr->{'content'});
                if ($metaname eq 'episodenumber') {
                    $meta{'episode'} = $content;
                } elsif ($metaname eq 'seriestitle') {
                    $meta{'seriestitle'} = $content;
                }
            }
        } elsif ('div' eq $tagname) {
            if (exists $attr->{'data-hls-media'} && !exists $meta{'streamUrl'}) {
                $meta{'streamUrl'} = $attr->{'data-hls-media'};
            }
        } elsif ('a' eq $tagname and $class eq 'season-link ui-state-selected') {
            if (exists $attr->{'title'} and not exists $meta{'season'}) {
                if ($attr->{'title'} =~ /[Ss]esong ([0-9]+)/) {
                    $meta{'season'} = $1;
                }
            }
        }
    };
    my $text_handler = sub {
        return unless @context;
        $text = $_[0];
    };
    my $end_handler = sub {
        my ($tagname) = @_;
        while (@context && (pop @context)->[0] ne $tagname) {}
        if ('title' eq $tagname && !exists $meta{'title'}) {
            $meta{'title'} = $text;
        } elsif ('h2' eq $tagname and scalar @context >= 5) {
            if ($context[-1]->[0] eq 'div'
                and $context[-1]->[1] eq 'box-heading'
                and $context[-2]->[1] eq 'season-box'
                and $context[-3]->[1] eq 'seasons-container') {
                $text =~ s/Sesong *//;
                $meta{'season'} = $text unless exists $meta{'season'};
            }
        } elsif ($tagname eq 'script') {
            if ($text =~ /nrk\.playerstats *=[^;]+ga: *{[^;]*"programTitle":"([^"]+)"/ms) {
                $meta{'playerStats.title'} = $1;
            }
        }
    };

    # HTML event parser
    my $p = HTML::Parser->new(api_version => 3,
                              start_h => [$start_handler, "tagname, attr"],
                              text_h => [$text_handler, "dtext"],
                              end_h => [$end_handler, "tagname"],
                              utf8_mode => 1,
                              unbroken_text => 1,
                              empty_element_tags => 1);
    $p->parse($html_content);

    # Some cleanups and formatting of values
    $meta{'title'} =~ s/^(NRK (Super )?TV)?[\s-]*|[\s-]*([0-9]+:[0-9]+)?$//g if exists $meta{'title'};
    if (exists $meta{'title'} and exists $meta{'seriestitle'}
        and $meta{'title'} eq $meta{'seriestitle'} and !exists $meta{'season'}
        and exists $meta{'playerStats.title'}) {
        $meta{'title'} = $meta{'playerStats.title'};
    }
    delete $meta{'playerStats.title'};
    $meta{'episode'} = sprintf("%02d", $meta{'episode'}) if exists $meta{'episode'};
    $meta{'season'} = sprintf("%02d", $meta{'season'}) if exists $meta{'season'};

    return \%meta;
}

sub print_metadata {
    my ($meta) = @_;
    foreach my $key (sort keys %$meta) {
        my $value = $meta->{$key};
        print ucfirst($key),":\t",$value,"\n";
    }
}

sub prepare_outfile {
    my ($opt_outfile, $opt_dir, $opt_meta, $meta) = @_;
    my ($outfile, $outdir);
    if ($opt_outfile) {
        $outfile = $opt_outfile;
    } elsif (exists $meta->{'title'}) {
        $outfile = basename $meta->{'title'};

        if (exists $meta->{'episode'}) {
            my $episode = $meta->{'episode'};
            my $season = exists $meta->{'season'} ? $meta->{'season'} : '01';
            $outfile = "$outfile S${season}E${episode}";
        }

        if (exists $meta->{'seriestitle'}) {
            $outdir = $meta->{'seriestitle'};
        } else {
            $outdir = $meta->{'title'};
            $outdir =~ s/([0-9]{2,4}\.){2}[0-9]{2,4}//;
            $outdir =~ s/^(\s|-)+|(\s|-)+$//g;
        }
        if (-d encode('UTF-8',$outdir) or $opt_dir) {
            $outfile = "$outdir/$outfile";
        }
    } else {
        die('No title metadata available, and no output file provided!');
    }
    $outfile = $outfile . '.mp4' unless $outfile =~ /\.mp4$/;

    if (! -d encode('UTF-8',dirname($outfile)) and !$opt_meta) {
        make_path(encode('UTF-8',dirname($outfile))) or die("Failed to create parent dirs of output file: $outfile");
    }
    
    return $outfile;
}

# Read list of URLs from a file
sub read_urls_from_file {
    my ($file) = @_;
    my @urls = ();
    open FILE, $file or die("Unable to open file: $file");
    while (<FILE>) {
        next if (/^\s*#/ or /^\s*$/);
        s/^\s*|\s*$//;
        chomp;
        push @urls, $_;
    }
    close FILE;
    return @urls;
}

# Generates a suitable log file name, based on output file and PID
sub generate_logfile_name {
    my ($outfile, $pid) = @_;
    my $name = basename $outfile;
    $name =~ s/\.[a-zA-Z0-9]+$//;
    $name =~ s/[^a-zA-Z0-9]+/_/g;
    return "ffmpeg-nrkrip-${name}-${pid}.log";
}

# Invoke ffmpeg to save stream URL to file with necessary compatiblity
# conversions.
# If async mode, returns PID and associated log file as list, otherwise returns
# ffmpeg exit code.
sub rip_stream {
    my ($streamUrl, $outfile, $opt_async, $opt_owr) = @_;
    if (my $pid = fork) {
        if ($opt_async) {
            my $logfile = &generate_logfile_name($outfile, $pid);
            print "FFmpeg background job started with sentinel PID:\t$pid\n";
            print "Log file:\t$logfile\n";
            return ($pid, $logfile);
        } else {
            wait;
            return $? >> 8 & 0xff;
        }
    } else {
        # FFmpeg sentinel process
        my @ffmpeg_opts = ('-c','copy','-bsf:a','aac_adtstoasc');
        push @ffmpeg_opts, '-y' if ($opt_owr);
        open LOGFH, ">&STDERR";
        if ($opt_async) {
            my $logfile = encode('UTF-8', &generate_logfile_name($outfile, $$));
            open LOGFH, ">$logfile" or die("Failed to open log file: $!");
            open STDOUT, ">&LOGFH";
            open STDERR, ">&LOGFH";
            open STDIN, "</dev/null";
        }

        system(FFMPEG,'-i',$streamUrl,@ffmpeg_opts,encode('UTF-8',$outfile));
        my $exitcode = $? >> 8;
        if ($? == -1) {
            print LOGFH "Failed to execute ffmpeg:\t$!\n";
        } elsif ($? & 127) {
            printf LOGFH "ffmpeg died with signal\t%d\n", ($? & 127);
        } else {
            if ($opt_async || $exitcode != 255) {
                printf LOGFH "ffmpeg exited with value\t%d\n", $exitcode;
            }
        }
        exit $exitcode;
    }
}

sub wait_for_jobs {
    my ($jobs, $num_waits) = @_;
    my $num_running = keys %$jobs;
    print "--- Waiting for background jobs ($num_running running) .. ---\n";
    while ($num_waits > 0 and (my $pid = wait) != -1) {
        my $url = $jobs->{$pid}->[1];
        my $exitcode = $? >> 8 & 0xff;
        print "Job\t$url\texited with code\t$exitcode\n";
        $num_waits--;
        delete $jobs->{$pid};
    }
    print "--- End waiting ---\n";
    print "\n";
}

sub print_version_exit {
    my $name = basename($0);
    print "$name v" . VERSION . "\n";
    printf "Perl v%vd\n", $^V;
    open FFMPEG_OUT, "ffmpeg -version|";
    print scalar <FFMPEG_OUT>;
    close FFMPEG_OUT;
    exit 0;
}

# Prints usage to STDOUT
sub print_usage_exit {
    my $name = basename($0);
    print <<"EOF";
Use: ${name} [opts] SOURCE [SOURCE ..]

SOURCE is typically a playback URL for an episode or program on
tv.nrk.no/tv.nrksuper.no. It can also be a file with list of such URLs.

You may alternativly provide direct HLS stream URLs, which will be ripped. This
may be used to rip from sources other than NRK.

By default, output files are saved to current directory, possibly with a
generated parent directory based on title.

--async,    Enable async mode - stream rips are executed in parallel as background jobs.
-a

--wait,     When using async mode, wait for all background jobs before exiting,
-w          and report their status as they finish.

--onlymeta, Only show extracted metadata from URL, do not actually rip video
-m          stream or write any files.

--outfile,  Optionally set output file. (Normally, a suitable file name is generated.)
-o          This option is not compatible with multiple URLs.

--jobs,     Max number of simultaneous background jobs (integer >= 1). Default is unlimited.
-j          Only applicable when using '--wait'.

--dir,      Always use a title-based directory as parent of output files, even
-d          though it does not already exist (will be created on demand).

-y          Always overwrite output files. Useful especially when running in async mode.

--version,  Show versions of script, Perl and ffmpeg.
-v
EOF
    exit 0;
}

# Main program flow begin
my ($opt_async,$opt_meta,$opt_dir,$opt_wait,$opt_jobs,$opt_owr,$opt_outfile) = (0,0,0,0,0,0,undef);
GetOptions('help|h' => \&print_usage_exit,
           'async|a' => \$opt_async,
           'onlymeta|m' => \$opt_meta,
           'dir|d' => \$opt_dir,
           'o|outfile=s' => \$opt_outfile,
           'w|wait' => \$opt_wait,
           'v|version' => \&print_version_exit,
           'j|jobs=i' => \$opt_jobs,
           'y' => \$opt_owr
    );

die('Error: missing URL(s)') if (! exists $ARGV[0]);
if ($opt_outfile and scalar @ARGV > 1) {
    die('Error: output file cannot be specified when multiple URLs are provided.');
}

print "--- NRK rip ---\n\n";

my %jobs = ();
my %urls = ();
my $stream_id = 0;
while (my $url = shift) {
    if (-f $url) {
        push @ARGV, &read_urls_from_file($url);
        next;
    }
    next if $urls{$url};
    $urls{$url} = 1;
    ++$stream_id;

    my $meta = &get_metadata($url);
    if (!exists $meta->{'streamUrl'}) {
        $meta->{'streamUrl'} = $url;
    }
    if (!exists $meta->{'title'}) {
        $meta->{'title'} = sprintf("Stream %03d", $stream_id);
        $meta->{'seriestitle'} = "Streams";
    }
    my $outfile = &prepare_outfile($opt_outfile,$opt_dir,$opt_meta,$meta);
    print "--- Stream metadata ---\n";
    &print_metadata($meta);
    print "Outfile:\t$outfile\n";
    print "--- End stream metadata ---\n\n";
    next if ($opt_meta);

    print "--- FFmpeg ---\n";
    if ($opt_async) {
        my ($pid, $logfile) = &rip_stream($meta->{'streamUrl'}, $outfile, $opt_async);
        $jobs{$pid} = [$logfile,$url];
    } else {
        &rip_stream($meta->{'streamUrl'}, $outfile, $opt_async, $opt_owr);
    }
    print "--- End FFmpeg ---\n\n";
    
    if ($opt_wait and $opt_jobs > 0 and keys %jobs >= $opt_jobs) {
        my $overflow = scalar (keys %jobs) - $opt_jobs;
        &wait_for_jobs(\%jobs, $overflow == 0 ? 1 : $overflow);
    }
}

if ($opt_wait and keys %jobs > 0) {
    &wait_for_jobs(\%jobs, scalar keys %jobs);
}

print "--- End NRK rip ---\n";
