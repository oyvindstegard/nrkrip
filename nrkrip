#!/usr/bin/env perl
# Rip video streams from tv.nrk.no/tv.nrksuper.no
# Requires ffmpeg on PATH and Perl modules 'WWW::Curl', 'HTML::Parser'
# This script will only output UTF-8 encoded data, both for output and
# generated file names.
#
# TODO ffmpeg progress output as percentage (by looking at timestamps)
#
# Author: oyvind.stegard@ifi.uio.no, http://stegard.net/

package nrkrip;

use strict;
use warnings;

use WWW::Curl::Easy;
use HTML::Parser;
use File::Basename qw(dirname basename);
use File::Path qw(make_path);
use Getopt::Long qw(:config bundling);
use Encode qw(encode decode);

# Encode strings printed to stdout/stderr as UTF-8
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

# Path to ffmpeg binary
use constant FFMPEG => 'ffmpeg';

# Version
use constant VERSION => '0.3';

# Fetch content at URL
# Takes URL as first argument, and a ref as second arg
# Returns http status code if request went through, otherwise a negative
# value is returned (which is the curl error code)
# Content will be stored in variable referred to by second argument
sub http_fetch_body {
    die("http_fetch_body: wrong number of arguments") if @_ != 2;
    my ($url, $content) = @_;
    if (!$url) { return undef };
    my $curl = WWW::Curl::Easy->new;
    $curl->setopt(CURLOPT_URL, $url);
    $curl->setopt(CURLOPT_FOLLOWLOCATION, 1);
    $$content = undef;
    $curl->setopt(CURLOPT_WRITEDATA, $content);
    my $retcode = $curl->perform();

    if ($retcode == 0) {
        return $curl->getinfo(CURLINFO_HTTP_CODE);
    } else {
        return -$retcode;
    }
}

# Takes URL as first argument.
# Returns a ref to a hash with metadata fields.
sub get_metadata {
    my ($url) = @_;
    if (not $url =~ /^https?:\/\/tv\.nrk(super)?\.no/) {
        return {};
    }

    my $html_content;
    &http_fetch_body($url, \$html_content) == 200 or die("Failed to fetch: $url");

    my %meta = ('url' => $url);
    my @context = ();
    my $text = '';

    # Season from URL (possibly)
    if ($url =~ /\/sesong-([0-9]+)/) {
        $meta{'season'} = $1;
    }

    # HTML parser handler routines
    my $start_handler = sub {
        my ($tagname, $attr) = @_;
        my $class = exists $attr->{'class'} ? $attr->{'class'} : '';
        push @context, [$tagname, $class];

        if ('meta' eq $tagname) {
            if (exists $attr->{'name'} && exists $attr->{'content'}) {
                my ($metaname, $content) = ($attr->{'name'}, $attr->{'content'});
                if ('episodenumber' eq $metaname) {
                    $meta{'episode'} = $content;
                } elsif ('seriestitle' eq $metaname) {
                    $meta{'seriestitle'} = $content;
                } elsif ('kategori_id' eq $metaname) {
                    $meta{'category'} = $content;
                }
            }
        } elsif ('div' eq $tagname) {
            if (exists $attr->{'data-hls-media'} && !exists $meta{'streamUrl'}) {
                $meta{'streamUrl'} = $attr->{'data-hls-media'};
            }
        } elsif ('a' eq $tagname and $class eq 'season-link ui-state-selected') {
            if (exists $attr->{'title'} and not exists $meta{'season'}) {
                if ($attr->{'title'} =~ /[Ss]esong ([0-9]+)/) {
                    $meta{'season'} = $1;
                }
            }
        }
    };
    my $text_handler = sub {
        return unless @context;
        $text = $_[0];
    };
    my $end_handler = sub {
        my ($tagname) = @_;
        while (@context && (pop @context)->[0] ne $tagname) {}
        if ('title' eq $tagname && !exists $meta{'title'}) {
            $meta{'title'} = $text;
        } elsif ('h2' eq $tagname and scalar @context >= 5) {
            if ($context[-1]->[0] eq 'div'
                and $context[-1]->[1] eq 'box-heading'
                and $context[-2]->[1] eq 'season-box'
                and $context[-3]->[1] eq 'seasons-container') {
                $text =~ s/Sesong *//;
                $meta{'season'} = $text unless exists $meta{'season'};
            }
        } elsif ('script' eq $tagname) {
            if ($text =~ /nrk\.playerstats *=[^;]+ga: *{[^;]*"programTitle":"([^"]+)"/ms) {
                $meta{'playerStats.title'} = $1;
            }
        }
    };

    # HTML event parser
    my $p = HTML::Parser->new(api_version => 3,
                              start_h => [$start_handler, "tagname, attr"],
                              text_h => [$text_handler, "dtext"],
                              end_h => [$end_handler, "tagname"],
                              utf8_mode => 1,
                              unbroken_text => 1,
                              empty_element_tags => 1);
    $p->parse($html_content);

    # Some cleanups, formatting of values and addition of derived values
    $meta{'title'} =~ s/^(NRK (Super )?TV)?[\s-]*|[\s-]*([0-9]+:[0-9]+)?$//g if exists $meta{'title'};
    if (exists $meta{'title'} and exists $meta{'seriestitle'}
        and $meta{'title'} eq $meta{'seriestitle'} and !exists $meta{'season'}
        and exists $meta{'playerStats.title'}) {
        $meta{'title'} = $meta{'playerStats.title'};
    }
    delete $meta{'playerStats.title'};
    $meta{'episode'} = sprintf("%02d", $meta{'episode'}) if exists $meta{'episode'};
    $meta{'season'} = sprintf("%02d", $meta{'season'}) if exists $meta{'season'};

    return \%meta;
}

# Try to fetch subtitle stream
# Returns subtitle stream as a string in ".srt" format if successful
sub get_subtitles {
    my ($cc_url) = @_;
    $cc_url =~ s/^(.*\.m3u8)~.*/$1/;
    my $content;
    return undef unless &http_fetch_body($cc_url, \$content) == 200;

    my @playlist_files = grep { /^[a-zA-Z0-9]/ } split("[\n\r]", $content);
    return undef unless scalar @playlist_files > 0;

    # TODO should use proper URL expansion here:
    (my $webvtt_url = $cc_url) =~ s/\/[^\/]+$//;
    $webvtt_url = $webvtt_url . "/" . $playlist_files[0];

    return undef unless &http_fetch_body($webvtt_url, \$content) == 200;

    # Convert WEBVTT to SRT
    $content = decode('UTF-8', $content);
    $content =~ s/([0-9]{2})\.([0-9]{3})/$1,$2/g;
    $content =~ s/.*?\n1/1/s;

    return $content;
}

# Print metadata to standard output
sub print_metadata {
    my ($meta) = @_;
    foreach my $key (sort keys %$meta) {
        my $value = $meta->{$key};
        print ucfirst($key),":\t",$value,"\n";
    }
}

# Generate dir and file name based on metadata or explicit file name
# Return path to output file
sub prepare_outfile {
    my ($opt_outfile, $opt_dir, $opt_meta, $meta) = @_;
    my ($outfile, $outdir);
    if ($opt_outfile) {
        $outfile = $opt_outfile;
    } elsif (exists $meta->{'title'}) {
        $outfile = basename $meta->{'title'};

        if (exists $meta->{'episode'}) {
            my $episode = $meta->{'episode'};
            my $season = exists $meta->{'season'} ? $meta->{'season'} : '01';
            $outfile = "$outfile S${season}E${episode}";
        }

        if (exists $meta->{'seriestitle'}) {
            $outdir = $meta->{'seriestitle'};
        } else {
            $outdir = $meta->{'title'};
            $outdir =~ s/([0-9]{2,4}\.){2}[0-9]{2,4}//;
            $outdir =~ s/^(\s|-)+|(\s|-)+$//g;
        }
        if (-d encode('UTF-8',$outdir) or $opt_dir) {
            $outfile = "$outdir/$outfile";
        }
    } else {
        die('No title metadata available, and no output file provided!');
    }
    $outfile = $outfile . '.mp4' unless $outfile =~ /\.mp4$/;

    if (! -d encode('UTF-8',dirname($outfile)) and !$opt_meta) {
        make_path(encode('UTF-8',dirname($outfile))) or die("Failed to create parent dirs of output file: $outfile");
    }
    
    return $outfile;
}

# Read list of URLs from a file
sub read_urls_from_file {
    my ($file) = @_;
    my @urls = ();
    open FILE, $file or die("Unable to open file: $file");
    while (<FILE>) {
        next if (/^\s*#/ or /^\s*$/);
        s/^\s*|\s*$//;
        chomp;
        push @urls, $_;
    }
    close FILE;
    return @urls;
}

# Generates a suitable log file name, based on output file and PID
sub generate_logfile_name {
    my ($outfile, $pid) = @_;
    my $name = basename $outfile;
    $name =~ s/\.[a-zA-Z0-9]+$//;
    $name =~ s/[^a-zA-Z0-9]+/_/g;
    return "ffmpeg-nrkrip-${name}-${pid}.log";
}


# Invoke ffmpeg to save stream URL to file with necessary compatiblity
# conversions.
# If async mode, returns PID and associated log file as list, otherwise returns
# ffmpeg exit code.
sub rip_stream {
    my ($streamUrl, $outfile, $opt_async, $opt_owr, $opt_subs) = @_;
    if (my $pid = fork) {
        if ($opt_async) {
            my $logfile = &generate_logfile_name($outfile, $pid);
            print "FFmpeg background job started with sentinel PID:\t$pid\n";
            print "Log file:\t$logfile\n";
            return ($pid, $logfile);
        } else {
            wait;
            return $? >> 8 & 0xff;
        }
    } else {
        # Sentinel process
        my @ffmpeg_opts = ('-c','copy','-bsf:a','aac_adtstoasc');
        push @ffmpeg_opts, '-y' if ($opt_owr);
        open LOGFH, ">&STDERR";
        if ($opt_async) {
            my $logfile = encode('UTF-8', &generate_logfile_name($outfile, $$));
            open LOGFH, ">$logfile" or die("Failed to open log file: $!");
            open STDOUT, ">&LOGFH";
            open STDERR, ">&LOGFH";
            open STDIN, "</dev/null";
        }
        # Subtitles
        if ($opt_subs and $streamUrl =~ m/\?cc1=(uri[^&]+)/) {
            my $cc_url = $1;
            $cc_url =~ s/^uri%3[dD]//;
            $cc_url =~ s/\+/ /g;
            $cc_url =~ s/%([A-Fa-f\d]{2})/chr hex $1/ge;
            if (my $subtitles = &get_subtitles($cc_url)) {
                (my $srtfile = $outfile) =~ s/\.[^\.]+$/.srt/;
                if ($opt_owr or not -e $srtfile) {
                    open SRTFILE, ">$srtfile" or die("Failed to open file for writing: $srtfile");
                    binmode SRTFILE, ':utf8';
                    print SRTFILE $subtitles;
                    print "Wrote subtitles to: $srtfile\n\n";
                    close SRTFILE;
                } else {
                    print "Warning: Not overwriting existing subtitle file: $srtfile\n";
                    print "         Use '-y' to overwrite files automatically.\n";
                }
            }
        }
        # FFmpeg
        system(FFMPEG,'-i',$streamUrl,@ffmpeg_opts,encode('UTF-8',$outfile));
        my $exitcode = $? >> 8;
        if ($? == -1) {
            print LOGFH "Failed to execute ffmpeg:\t$!\n";
        } elsif ($? & 127) {
            printf LOGFH "ffmpeg died with signal\t%d\n", ($? & 127);
        } else {
            if ($opt_async || $exitcode != 255) {
                printf LOGFH "ffmpeg exited with value\t%d\n", $exitcode;
            }
        }
        exit $exitcode;
    }
}

sub wait_for_jobs {
    my ($jobs, $num_waits) = @_;
    my $num_running = keys %$jobs;
    print "--- Waiting for background jobs ($num_running running) .. ---\n";
    while ($num_waits > 0 and (my $pid = wait) != -1) {
        my $url = $jobs->{$pid}->[1];
        my $exitcode = $? >> 8 & 0xff;
        print "Job\t$url\texited with code\t$exitcode\n";
        $num_waits--;
        delete $jobs->{$pid};
    }
    print "--- End waiting ---\n";
    print "\n";
}

sub print_version_exit {
    my $name = basename($0);
    print "$name v" . VERSION . "\n";
    printf "Perl v%vd\n", $^V;
    open FFMPEG_OUT, "ffmpeg -version|";
    print scalar <FFMPEG_OUT>;
    close FFMPEG_OUT;
    exit 0;
}

# Prints usage to STDOUT
sub print_usage_exit {
    my $name = basename($0);
    print <<"EOF";
Use: ${name} [opts] SOURCE [SOURCE ..]

SOURCE is typically a playback URL for an episode or program on
tv.nrk.no/tv.nrksuper.no. It can also be a file with list of such URLs.

You may alternativly provide direct HLS stream URLs, which will be ripped. This
may be used to rip from sources other than NRK.

By default, output files are saved to current directory, possibly with a
generated parent directory based on title.

--async,   Enable async mode - stream rips are executed in parallel as background jobs.
-a

--wait,    When using async mode, wait for all background jobs before exiting,
-w         and report their status as they finish.

--meta,    Only show extracted metadata from URL, do not actually rip video
-m         stream or write any files.

--out,     Optionally set output file. (Normally, a suitable file name is generated.)
-o         This option is not compatible with multiple URLs.

--jobs,    Max number of simultaneous background jobs (integer >= 1). Default is unlimited.
-j         Only applicable when using '--wait'.

--dir,     Always use a title-based directory as parent of output files, even
-d         though it does not already exist (will be created on demand).

--subs,    Experimental: try to fetch and convert subtitles. If successful, the subtitles will
-s         be saved in ".srt" format using the same basename as the output file.

-y         Always overwrite output files. Useful especially when running in async mode.

--version, Show versions of script, Perl and ffmpeg.
-v
EOF
    exit 0;
}

# Main program flow begin
my ($opt_async,$opt_meta,$opt_dir,$opt_wait,$opt_jobs,$opt_subs,$opt_owr,$opt_outfile) = (0,0,0,0,0,0,undef);
GetOptions('h|help' => \&print_usage_exit,
           'a|async' => \$opt_async,
           'm|meta' => \$opt_meta,
           'd|dir' => \$opt_dir,
           'o|out=s' => \$opt_outfile,
           'w|wait' => \$opt_wait,
           'v|version' => \&print_version_exit,
           'j|jobs=i' => \$opt_jobs,
           's|subs' => \$opt_subs,
           'y' => \$opt_owr
    );

die('Error: missing URL(s)') if (! exists $ARGV[0]);
if ($opt_outfile and scalar @ARGV > 1) {
    die('Error: output file cannot be specified when multiple URLs are provided.');
}

print "--- NRK rip ---\n\n";

my %jobs = ();
my %urls = ();
my $stream_id = 0;
while (my $url = shift) {
    if (-f $url) {
        push @ARGV, &read_urls_from_file($url);
        next;
    }
    next if $urls{$url};
    $urls{$url} = 1;
    ++$stream_id;

    my $meta = &get_metadata($url);
    if (!exists $meta->{'streamUrl'}) {
        $meta->{'streamUrl'} = $url;
    }
    if (!exists $meta->{'title'}) {
        $meta->{'title'} = sprintf("Stream %03d", $stream_id);
        $meta->{'seriestitle'} = "Streams";
    }

    my $outfile = &prepare_outfile($opt_outfile,$opt_dir,$opt_meta,$meta);
    print "--- Stream metadata ---\n";
    &print_metadata($meta);
    print "Outfile:\t$outfile\n";
    print "--- End stream metadata ---\n\n";
    next if ($opt_meta);

    print "--- Stream rip ---\n";
    if ($opt_async) {
        my ($pid, $logfile) = &rip_stream($meta->{'streamUrl'}, $outfile, $opt_async, $opt_owr, $opt_subs);
        $jobs{$pid} = [$logfile,$url];
    } else {
        &rip_stream($meta->{'streamUrl'}, $outfile, $opt_async, $opt_owr, $opt_subs);
    }
    print "--- End stream rip ---\n\n";
    
    if ($opt_wait and $opt_jobs > 0 and keys %jobs >= $opt_jobs) {
        my $overflow = scalar (keys %jobs) - $opt_jobs;
        &wait_for_jobs(\%jobs, $overflow == 0 ? 1 : $overflow);
    }
}

if ($opt_wait and keys %jobs > 0) {
    &wait_for_jobs(\%jobs, scalar keys %jobs);
}

print "--- End NRK rip ---\n";
